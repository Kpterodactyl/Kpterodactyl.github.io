---
layout:     post
title:      Scala语法初学笔记
subtitle:   基础语法和实例
date:       2017-07-03  09:27:08 +0800
author:     Memory
header-img: img/post-bg-js-module.jpg
catalog: MPI
tags:
    - Scala
    - Spark
---
记录一下自己开始学习Scala的基础语法，以后便于自己查阅。    
## 基础部分 ##   

变量声明 var n = 9     
输入 line = readLine()   
**do...while()** 循环示例：    
{% highlight ruby %}
	  var line = ""
	  do {
	    println("Please input some words blow......")
	    line = readLine()
	    println("Read: " + line)
	  } while (line != "")
{% endhighlight %}   

**def doWhile()** 函数定义
{% highlight ruby %}
def doWhile(){
    var line = ""
    do {
       line = readLine()
       println("Read: " + line)
	  } while (line != "")
}
{% endhighlight %}    
**if表达式   **  
{% highlight ruby %}
val spark = 7
if(spark>=5) "adult" else "child"
{% endhighlight %}
结果 String = adult
在Scala中的if表达式是有值的，但Java中是没有的。        
**Scala中object的理解**：    
object作为Scala中的一个关键字，相当于Java中的public static class这样的一个修饰符，也就是说object中的成员都是静态的，事实上object是Scala中的静态类，不是对象。object中的内容class都可以在没有实例的时候直接去调用。object中的apply方法是class对象生成的工厂方法，用于控制对象的生成；
{% highlight ruby %}
object HelloOOP {
  def main(arg:Array[String]) :Unit = {
    val HelloOOP = HelloOOP()
    HelloOOP.sayHello
  }
  def apply():HelloOOP = {
    new HelloOOP
  }
}
{% endhighlight %}
变量声明为**lazy**：         
表示这个变量只有在第一次使用时，才会发生计算，比如说打开文件，打开数据库，操作网络
{% highlight ruby %}
object LazyOps {

  def main(args: Array[String]): Unit = {
    lazy val file = Source.fromFile("E:\\SparkWangJialin.txt") 
    
    println("Scala")
	for (line <- file.getLines) println(line)    
  }
}
{% endhighlight %}
**try...catch...finally**的使用
首先尝试完成try中的操作 ，RuntimeException中定义要错误的提示语，在catch中可以用e.getMessage()接收RuntimeException的内容。
{% highlight ruby %}
    val n = 99
    try {
	    if (n % 2 == 0) n /2 else throw 
	    	new RuntimeException("N must be event")
	    // Use the file 
    }catch {
      case e : Exception => println("The exception is :" + e.getMessage())
    }finally{
    	println(n)
    }
{% endhighlight %}
程序运行结果 The exception is:N must be double       
            99
**for循环**
{% highlight ruby %}
	for (i <- 1 to 10) {
	   println("Number is :" + i)
    }
{% endhighlight %}
**数组 **    定长数组(Array) 变长数组(Arraybuffer)      
**不可变数组**声明  `var z = new Array[Int](3)`        
创建不可变数组 `val arr1 = Array(1,3,5)`      
访问数组元素的值 `arr1(2)` //访问数组元素第三个值    
修改数组元素的值 `arr1(2) = 8`   
数组遍历      
{% highlight ruby %}
var total = 0.0
for (i <-0 to (arr1.length -1)) {
	total += arr1 //计算总和
}
var max = arr1(0);
for(i <- 1 to (arr1.length -1) ) {
	if (arr1(i) > max） max =arr1(i)
}
{% endhighlight %}
**创建可变数组** --可对数组元素增添或删减元素     
首先导入包  import scala.collection.mutable.ArrayBuffer     
{% highlight ruby %}
    val b = ArrayBuffer[Int]()
    b += 1 //追加元素  内容为1 
    b += (1, 2, 3, 5)   //内容为 (1, 1, 2, 3, 5)
    b ++= Array(8, 13, 21) //在现有的b的后面追加8, 13, 21 三个元素 （1, 1, 2, 3, 5, 8, 13, 21)
    b.trimEnd(5) //删除b后面的5个元素 结果为(1, 1, 2)
    b.insert(2, 6) //下标为2元素增加元素6，后面的元素后移 结果为 (1, 1, 6, 2)
    b.insert(2, 7, 8, 9) 在下标为2元素位置插入(7,8,9)结果为 (1, 1, 7, 8, 9, 6, 2)
    b.remove(2) //删除下标为2元素 (1, 1, 8, 9, 6, 2)
    b.remove(2, 3) //删除下标为2元素开始的三个元素，包括下标为2元素 (1, 1, 2）
    b.toArray
{% endhighlight %}
数组求和：`arrBuffer.sum`    
数组求最大值：`arrBuffer.max`    
数组排序：`scala.util.Sorting.quickSort(arrBuffer)`       
   
## Map和Tuple ##      

**1. Map**   
`val map = Map("book"->10,"gun"->18,"ipad"->1000)`      
默认情况下Map构造的是不可变集合，里面的内容不可修改，若要修改器内容，应：      
`val scores = scala.collection.mutable.Map("Scala" -> 7, "Hadoop" -> 8, "Spark" -> 10 )`    
此时为可修改的    
`scores（"Spark"->15)`     
Map中if...elae的变形       
`val hadoopScore = scores.getOrElse("Hadoop", 0)`     
表示如果这个scores中有Hadoop则取出它的值，如果没有，值就为0。 整体实例如下
{% highlight ruby %}
  //不可变集合
  val map = Map("book"->10,"gun"->18,"ipad"->1000)  
  for((k,v) <- map) yield (k,v * 0.9)
  //可变集合
  val scores = scala.collection.mutable.Map("Scala" -> 7, "Hadoop" -> 8, "Spark" -> 10 )
  val hadoopScore = scores.getOrElse("Hadoop", 0)
  scores += ("R" -> 9)
  scores -= "Hadoop"
{% endhighlight %}
**2. Tuple**
Tuple元组可以包含不同类型的元素，例如`val tuple =(1,2,3.14,"Rocky","Spark")`           
Tuple的访问 `val third = tuple._3` 结果为3.14，其访问下标是从1开始的

## 数组操作合集 ##
初始集合的每个元素做一次翻倍
{% highlight ruby %}
val c = Array(2, 3, 5, 7, 11)                    
//> c  : Array[Int] = Array(2, 3, 5, 7, 11)
val result = for (elem <- c) yield  2 * elem      
//> result  : Array[Int] = Array(4, 6, 10, 14, 22) 
{% endhighlight %}
for 循环中的 **yield** 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala 中 for 循环是有返回值的。如果被循环的是 Map，返回的就是  Map，被循环的是 List，返回的就是 List，以此类推。
分步结果展示,更好解释了yield
{% highlight ruby %}
scala> val c = Array(2,3,5,7,11)
c: Array[Int] = Array(2, 3, 5, 7, 11)

scala> for (elem <- c if elem % 2 == 0) yield 2 * elem
res5: Array[Int] = Array(4)

scala> c.filter(_ % 2 == 0).map(2 * _)
res6: Array[Int] = Array(4) 
//filter方法返回了所有使假设条件（_ % 2 == 0）为真的结果，  

scala> c.filter(_ % 2 == 0)
res7: Array[Int] = Array(2)

scala> for (i <- 1 to 4) yield i * 2
res8: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8)
{% endhighlight %}

对数组中的内容做格式处理
{% highlight ruby %}
scala> val arr = Array(1,7,9)
arr: Array[Int] = Array(1, 7, 9)

scala> arr.mkString(" and ")
res9: String = 1 and 7 and 9

scala> arr.mkString("<",",",">")
res10: String = <1,7,9>
{% endhighlight %} 
对二维数组的声明   
{% highlight ruby %}
val matrix = Array.ofDim[Double](3,4)
matrix: Array[Array[Double]] = Array(Array(0.0, 0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0, 0.0))
{% endhighlight %} 
可直接赋值`matrix(2)(3) = 5`
指明数组内元素类型定长   
{% highlight ruby %}
val triangle = new Array[Array[Int]](10)
triangle: Array[Array[Int]] = Array(null, null, null, null, null, null, null, null, null, null)
{% endhighlight %} 









    
