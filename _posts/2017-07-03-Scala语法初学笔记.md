---
layout:     post
title:      Scala语法初学笔记
subtitle:   基础语法和实例
date:       2017-07-03  09:27:08 +0800
author:     Memory
header-img: img/post-bg-js-module.jpg
catalog: MPI
tags:
    - Scala
    - Spark
---
记录一下自己开始学习Scala的基础语法，以后便于自己查阅。    
## 基础部分 ##   

变量声明 var n = 9     
输入 line = readLine()   
**do...while()** 循环示例：    
{% highlight ruby %}
	  var line = ""
	  do {
	    println("Please input some words blow......")
	    line = readLine()
	    println("Read: " + line)
	  } while (line != "")
{% endhighlight %}   

**def doWhile()** 函数定义
{% highlight ruby %}
def doWhile(){
    var line = ""
    do {
       line = readLine()
       println("Read: " + line)
	  } while (line != "")
}
{% endhighlight %}    
**if表达式   **  
{% highlight ruby %}
val spark = 7
if(spark>=5) "adult" else "child"
{% endhighlight %}
结果 String = adult
在Scala中的if表达式是有值的，但Java中是没有的。        
**Scala中object的理解**：    
object作为Scala中的一个关键字，相当于Java中的public static class这样的一个修饰符，也就是说object中的成员都是静态的，事实上object是Scala中的静态类，不是对象。object中的内容class都可以在没有实例的时候直接去调用。object中的apply方法是class对象生成的工厂方法，用于控制对象的生成；
{% highlight ruby %}
object HelloOOP {
  def main(arg:Array[String]) :Unit = {
    val HelloOOP = HelloOOP()
    HelloOOP.sayHello
  }
  def apply():HelloOOP = {
    new HelloOOP
  }
}
{% endhighlight %}
变量声明为**lazy**：         
表示这个变量只有在第一次使用时，才会发生计算，比如说打开文件，打开数据库，操作网络
{% highlight ruby %}
object LazyOps {

  def main(args: Array[String]): Unit = {
    lazy val file = Source.fromFile("E:\\SparkWangJialin.txt") 
    
    println("Scala")
	for (line <- file.getLines) println(line)    
  }
}
{% endhighlight %}
**try...catch...finally**的使用
{% highlight ruby %}
    val n = 99
    try {
	    val half = if (n % 2 == 0) n /2 else throw 
	    	new RuntimeException("N must be event")
	    // Use the file 
    }catch {
      case e : Exception => println("The exception is :" + e.getMessage())
    }finally{
    }
{% endhighlight %}
**for循环**
{% highlight ruby %}
	for (i <- 1 to 10) {
	   println("Number is :" + i)
    }
{% endhighlight %}
数组     
**不可变数组**声明  `var z = new Array[Int](3)`    
创建不可变数组 `val arr1 = Array(1,3,5)`      
访问数组元素的值 `arr1(2)` //访问数组元素第三个值    
修改数组元素的值 `arr1(2) = 8`   
数组遍历      
{% highlight ruby %}
var total = 0.0
for (i <-0 to (arr1.length -1)) {
	total += arr1 //计算总和
}
var max = arr1(0);
for(i <- 1 to (arr1.length -1) ) {
	if (arr1(i) > max） max =arr1(i)
}
{% endhighlight %}
**创建可变数组** --可对数组元素增添或删减元素     
首先导入包  import scala.collection.mutable.ArrayBuffer     
{% highlight ruby %}
    val b = ArrayBuffer[Int]()
    b += 1 //追加元素
    b += (1, 2, 3, 5) 
    b ++= Array(8, 13, 21) //在现有的b的后面追加8, 13, 21 三个元素
    b.trimEnd(5) //删除b后面的三个元素
    b.insert(2, 6) //第2个元素增加元素6，后面的元素后移
    b.insert(2, 7, 8, 9) 
    b.remove(2) //删除第5个位置的元素
    b.remove(2, 3) //删除第2个位置开始的三个元素，包括第2个位置
    b.toArray
{% endhighlight %}
数组求和：`arrBuffer.sum`    
数组求最大值：`arrBuffer.max`    
数组排序：`scala.util.Sorting.quickSort(arrBuffer)`       
   
## Map和Tuple ##      

**1. Map**   
`val map = Map("book"->10,"gun"->18,"ipad"->1000)`      
默认情况下Map构造的是不可变集合，里面的内容不可修改，若要修改器内容，应：      
`val scores = scala.collection.mutable.Map("Scala" -> 7, "Hadoop" -> 8, "Spark" -> 10 )`    
此时为可修改的    
`scores（"Spark"->15)`     
Map中if...elae的变形       
`val hadoopScore = scores.getOrElse("Hadoop", 0)`     
表示如果这个scores中有Hadoop则取出它的值，如果没有，值就为0。 整体实例如下
{% highlight ruby %}
  //不可变集合
  val map = Map("book"->10,"gun"->18,"ipad"->1000)  
  for((k,v) <- map) yield (k,v * 0.9)
  //可变集合
  val scores = scala.collection.mutable.Map("Scala" -> 7, "Hadoop" -> 8, "Spark" -> 10 )
  val hadoopScore = scores.getOrElse("Hadoop", 0)
  scores += ("R" -> 9)
  scores -= "Hadoop"
{% endhighlight %}
**2. Tuple**
Tuple元组可以包含不同类型的元素，例如`val tuple =(1,2,3.14,"Rocky","Spark")`           
Tuple的访问 `val third = tuple._3` 结果为3.14，其访问下标是从1开始的







    
