---
layout:     post
title:      动态共乘调度算法回顾
subtitle:   论文阅读笔记
date:       2018-05-22  08:15:08 +0800
author:     Memory
header-img: img/post-bg-transport.png
catalog: 数据结构
tags:
    - Dijkstra
---
出租车服务是城市交通的重要组成部分，对交通阻塞和空气污染造成了巨大的影响，对人体健康有着重大不利影响，共享出粗车出行时一种可以消除这种影响的可能途径。
以下内容为拼车算法涉及的经典论文汇总整理：

1. Santi, Paolo, et al. "Quantifying the benefits of vehicle pooling with shareability networks." Proceedings of the National Academy of Sciences 111.37 (2014): 13290-13294.

2. Ma S, Zheng Y, Wolfson O (2013) T-Share: A large-scale dynamic taxi ridesharing service. Proc IEEE ICDE (IEEE, Brisbane, QLD), pp 410–421


3. Ta, Na, et al. "An Efficient Ride-Sharing Framework for Maximizing Shared Route." IEEE Transactions on Knowledge and Data Engineering 30.2 (2018): 219-233.


拼车算法的基本实现思路为：根据打车人口密度和时间、地点上下文确定最优路线，本质还是特征选择。在算法模型中，城市路网抽象为一个有向图结构：节点表示十字路口，边表示道路；但对于拼车业务，优先选择拼车密度大的路径。有了模型，就可以用路径规划算法来寻优。最简单的是Dijkstra搜索算法，也是今天大多数搜索算法的基石，但是在工程环境下，Dijkstra没法处理大规模的图结构，因为搜索效率低；于是变通为层次结构来提升性能，通过预处理所有短路线，达到毫秒级的全路径计算。

所以最终的方案应该是：实时刷新部分图结构完成预处理，并将图结构划分为一个个小格栅，通过并行计算加速服务响应。

具体实现可参考——**Uber 路径优化开源项目**（https://github.com/Project-OSRM/osrm-backend）

**Hubcab** 上面给出的纽约拼车的解决方案，是物联网和数据分析相结合的产物
http://hubcab.org/#13.00/40.7371/-73.9221

## 论文1对应Hubcab系统 ##

用大数据的方法，将拼车这个时空共享问题，转换成了图论（Graph Theory）框架，发明了“共享网络”（Shareability Network）模型。实验背景为曼哈顿，在实验中定义了两个参数：可共乘系数k－最大可共乘路程数，服务质量Δ－用户可承受的最大服务延迟（即时间窗），选择将服务质量参数定义为绝对时间，而不是作为旅行时间的百分比增加，是合理的，在文献（T－share）中也有类似的实现。

可共享网络将时空共享问题转化为提供高效解决方案的图论框架。
[![image.jpg](https://s31.postimg.cc/foq3yk8d7/image.jpg)](https://postimg.cc/image/u7x8zz1hz/)

**A**表示7个请求在曼哈顿。

**B**构建k＝2的共享网络，可能潜在的旅行被连接在一起的，如果满足时间窗限制。行程1和4不能被共享因为共享行程的总长应该大于单个行程相加之和。同样行程7是一个孤立的路线，无法和其它行程共享。

**C**可共享网络的最大匹配的到了最大数量的共享旅程对。

**D**实现最大匹配的策略结果。

**E**或者，根据最大加权得到可共享性网络的匹配策略，给出解决方案应具有最小的总行程时间，在这种情况下的结果会与未加权的最大匹配的解决方案不同。在图中的示例中，只有两对旅行是共享的，但节省的行程时间量，由匹配的链路权重总和30 + 16给出，是最佳的策略（k=2只能两两组合）。

**F**实现最大权重的策略结果。

**G**图中三种情况中的每一种都涉及多次要共享的行程Ti，每个情况的行程初始时间不同。最上边的情况， k=2对应的出租车可容纳量≥2。中间的情况，k＝3三段旅程可以被共享，但对应的出租车可容纳量≥2即可，因为T2和T3没有交叠。最下面的情况，k=3,对应的出租车可容纳量≥3(假设每段旅程对应的乘客数为1，根据Bloomberg M, Yassky D (2014) New York City 2014 Taxicab FactBook (New York City Taxi and Limousine Commission, New York)的报告中总结，平均乘客数为1.3)

如上图所示，在共享网络中如果两个点间的距离可以满足服务质量Δ的约束，则可以在两点之间建立一条连线（A和B图），服务质量Δ的大小对共享网络拓扑的性质有着很大的影响，由于时间聚合网络的影响，Δ增加共享拓扑会变得致密，用更直观的方式来表示就是乘客对于共乘的时间窗越大，等待约有耐心，可共乘的可能性越大，如下图所示(图中示范的为100个连续的行程对于两个不同的Δ，图中并不体现节点位置)。对于k>2的值，可共享性网络的超图结构中至多k个节点可以通过链接同时连接。由于计算原因k值对问题的可解决性有实质的影响，当k = 2时问题易于处理，当k=3时，启发式可行，而k≥4时，计算难以处理。这个约束意味着出租车共享服务这一应用程序，可能只能结合一个有限的旅行次数。但是，正如我们下面结果所示，即使是最低限度可能的行程组合数量（k = 2）可以提供巨大的数量的共乘对于像纽约这样密集的社区。
[![image.png](https://s31.postimg.cc/qbjx40bdn/image.png)](https://postimg.cc/image/e9oj9v253/)
可以根据如下两个标准确定最优的共乘策略：

1.最大化可共乘的数量

2.最小各旅程的累积时间

#### 实验部分
在实验中应用了New York 2011年的数据集，生成的共享网络有约150百万的节点和大于100百万的边。在整个共享网络已知的情况下，应用最大化可共乘数量的策略，采用Oracle approach models，得到了A和B结果。B图为将共享行程的百分比作为最大化共享行程（最大行程）的两个考虑的优化标准，并最大限度地减少总行程时间（最短时间），最多可分享k = 2次行程。C图通过固定公式随机去掉部分旅程，来调整每天的旅程数。
[![image.png](https://s31.postimg.cc/vmytor017/image.png)](https://postimg.cc/image/5enozdfxj/)

## 论文2TShare ##

论文实现的效果为多服务了25%的出租车用户同时减少了13%的行驶距离。主要创新点为：

1.通过时空索引的方式完成快速的候选出租车搜索策略

2.惰性的最短路径计算方法

动态拼车问题本质上是一个类似贪婪问题的求解，最小化出租车总行驶路程是一个NP难问题，可抽象为Total Distance Optimization Taxi Ridesharing Problem (TDOTRP)作为Travelling Salesman Problem with Time Window (TSPTW)旅行商问题的概括。

[![image.png](https://s31.postimg.cc/3t8f7axx7/image.png)](https://postimg.cc/image/5xss8dzjr/)

文中建立了动态共乘服务的框架，如红色箭头箭头所示，出租车在参加搭乘服务时，或者乘客上下车时或者在某个频率（例如，每20分钟一次）将其状态上载到运营中心），同时连接到服务。该系统维护出租车的**时空索引**以用于快速用户查询处理。一旦收到出租车的新状态或出租车的路线被服务重新安排，索引将被更新。

乘客向系统提交查询并接收服务的回应。如实线蓝色箭头所示，系统的所有传入查询都会流入**队列**，并按照**先来先服务原则**进行处理。对于查询队列顶部的每个查询队列，系统调用Taxi Searching模块来搜索一组可能基于最新索引满足查询的候选出租车{Taxis}。给定结果集{Taxis}，系统调用Scheduling模块将插入请求去查询结果集中满足条件的出租车（请求的乘客数小于出租车的承载范围，满足请求乘客的时间窗限制且满足待插入出租车当前乘客的时间窗限制）。如果请求可以被满足，给乘客响、通知出租车、并更新时空索引。

虽然从需求上来看K Nearest Neighbour (KNN)近似，但KNN并不完全适用，动态共乘的需求并不局限于查询附近的K辆车（K为固定值），拼车是根据时间窗过滤掉不符合规定的出租车。文中提出将路网进行网格划分，取路网中心的一个点作为矛点Ci，如图A，计算各个点之间的最短距离和行驶时间（不是本文的重点，选用固定的行驶速度进行估算），距离和时间Dij＝（tij，dij）以矩阵的形式存储，如图B所示。

[![image.png](https://s31.postimg.cc/60h990xqz/image.png)](https://postimg.cc/image/ce6cca2mv/)

每一个网格Gi有**三个列表**用于车辆搜索：**1和2均为静态列表，只需要计算一次。**

1、一个时间顺序的网格列表，从各个网格到Gi所需行驶时间的排序；

2、一个空间有序的网格列表，从各个网格到Gi所需行驶距离的排序；

3、网格内出租车和在特定时间段即将驶入Gi的出租车列表，该列表是动态变化的，每辆车驶出Gi时将被移除，每辆车驶入Gi时将被插入,网格中出租车的时间戳也会在收到更新的GPS信号之后更新。每辆出租车的ID都有时间戳标记；

[![image.png](https://s31.postimg.cc/dym8oa4m3/image.png)](https://postimg.cc/image/bu1vn72zb/)

#### 单边搜索的车辆共乘

在下图中可以看到当前有一个请求位于g7网格，即请求的起始点位于g7。右边为当前的时序网格列表，g7按照算法会被第一个挑选。

[![image.png](https://s31.postimg.cc/ckz777fgb/image.png)](https://postimg.cc/image/4s8jf89h3/)

其余的出租车如果 `ti7+tcur <= Q.wp.l` 满足时间窗需求也可以被选择，根据时序网格中的顺序检验网格中车辆的时间窗约束是否可以被满足，如下图所示，如果可以则添加到出租车候选集中。可以在最小路程增量的情况下满足请求的出租车一定会被包含在某一个选中的网格之中。但因为单边搜索的车辆共乘只考虑了在起始点附近，所以会导致在之后很多出租车回收。会增加整体的计算负担。

[![image.png](https://s31.postimg.cc/vh0acvrtn/image.png)](https://postimg.cc/image/u1ypo5qqf/)

#### 双边搜索的车辆共乘

双边搜索的车辆共乘的搜索过程从起点和终点同时展开搜索，在下图中可以看到g7和g2是请求的起点和终点，由斜线填充的部分为在起点附近可能的网格，具体选择过程与单边搜索的车辆共乘过程相同，红色字母代表了g7的空间有序的网格列表。由红点填充的部分为在终点附近可能的网格。
[![image.png](https://s31.postimg.cc/498i2zod7/image.png)](https://postimg.cc/image/juptmy0bb/)

算法维持了两个用来存储起点Q.o和终点Q.d的出租车集合So和sd，两集合初始为空。在各个网格中检索出租车的顺序为

Step1:g7->g2

Step2:g3->g6

Step3:g9

两两位一组在每一步结束后取So和Sd的交集，如果Step1的组合取交集后不为空，为保证最小增量的行驶距离，则不会进行Step2的计算，若为空则进行step2。在Step3中Sd没有符合要求的网格，则g9和g2、 g6同是取交集，如下图所示。（存疑：在Step2的时候就应该Sd不后移，在能保证最小的距离增量，应该增大匹配次数）。论文中也提到了根据其双边搜索的车辆共乘策略找到的出租车集合的行驶距离增量不一定是最小的，但损失的距离优化部分可以在更小的出租车集合进行调度计算负担中弥补回来。在实验中可以得出相较于单边搜索的车辆共乘策略出租车候选集的大小减少了50%而行驶距离只增加了1%。
[![image.png](https://s31.postimg.cc/jiled28jv/image.png)](https://postimg.cc/image/wmqypr0lj/)

#### 调度模块

在本节会讲解如何将一个请求Q插入到出租车V的调度状态中以及惰性的最短路径计算策略。首先要进行插入可行性检查，在逻辑上看，分为两步（1）在原旅程计划中插入Q请求的起始点（2）在原旅程计划中插入Q请求的下车点。系统在所有可行的插入方案中选取路程增量最小的方案。

[![image.png](https://s31.postimg.cc/576y5dc5n/image.png)](https://postimg.cc/image/cn67r5zuv/)

为避免时间延迟导致到达原始计划Q.o点后的任何点点延迟，引入了松弛时间。松弛时间被定义为在每个调度节点，对调度队列中的任意节点Vi，乘客可忍受的出租车Vi的到达时间减出租车Vi的预计到达时间大于或等于零才能满足Vi的时间窗限制。我们可以使用松弛时间作为快捷方式来检查是否由于插入造成的延迟破坏了计划中任何后续点上的及时到达情况。在上图中灰色的节点均位于Q.o之后需要通过松弛时间的检验。

在惰性的最短路径计算策略中利用**预先计算的网格距离矩阵**，**三角不等式**和**缓存**来加速可行性检查的过程。如果在缓存中没有，则计算起始点O和终止点D运行时间的时间下界（通过预先计算的网格间运行距离和三角不等式），通过三角形两边之差得到 `OD的下界≥CiCj－OCi－DCj` 其中CiCj是提前计算好的，在同一网格中的OCi和DCj距离较好计算。通过下限约束，可以更快地进行插入的可行性检验。只有当下界不违反时间约束时，算法才需要继续计算点O和D之间的最短时间路径。

很明显，网格大小会影响网络的懒惰最短路径计算策略有效性。一方面，如果网格的粒度太粗，即每个网格单元也是大，网格单元内的路由将是昂贵的，其中打败懒惰策略的主要目的;在另一方面，如果网格的粒度太细，即每个网格单元太小，更新网格单元的出租车列表的成本，即在出租车打算进入网格时更新时间戳的代价会很高。

**定价策略**文中提出合理策略：（i）每辆的士车费（每英里）多名乘客的费用比单人多乘客; （ii）共用距离的士费用均匀分配在乘客中;越多的人分享一次旅程，每个人为乘坐而付的车费越少。


#### 实验部分

文中用真实的北京路网进行实验包含106,579个道路节点和141,380个路段。**出租车轨迹**：出租车轨迹数据集包含GPS超过33,000辆出租车在87天内记录的轨迹从2011年的3月到5月。共有四种共乘策略（两两组合），在搜索策略中是单边搜索（single）还是双边搜索（Double），在调度策略中是要查询所有储蓄车选最优（Best－fit）还是只找到第一个满足条件的出租中就好（first－fit），四种分别表示为SB、SF、DB和DF。同时定义了Non-Ridesharing method (NR)没有共乘的状态。从满意率对比结果看随着查询数量通胀指数的变化，四种共乘方式比NR均高于25%）。满意率SF表现最好，节约行驶路程SB最好，节约了13%的路程。同时通过分析**在每次请求中每个网格被访问的次数**、**在每次请求中道路节点被访问的次数** 、**在每次请求中出租车被访问的次数**发现对于不同的不同的共享方式，随着查询数量通胀指数的增加计算量并没有明显的突增。DB的计算量明显小于SB，在某些情况下DB也小于SF。双边搜索的确会带来小幅旅行距离的增长，但换来了显着减少的计算成本。

当查询数量通胀指数＝2时，采用惰性的最短路径计算策略的DB方法比不采用降低了83%。且实验表明，共乘会给出租车司机带来更大的收益。

[![image.png](https://s33.postimg.cc/qb6adxvmn/image.png)](https://postimg.cc/image/6tbmxzyor/)

## 论文3 ##
文中提出了两种共乘的模式：**join-based sharing**,**search-based sharing**。The shared route percentage(SRP) 是共享路径占总行驶路径的比例。整体目标为：最大化整体资源的共享情况（包括司机和乘客）。

- 对于以加入为基础的join-basedRS： 有一组出租车和一组乘客，目的是计算的到最大SRP的<车辆,乘客>对，适用于高峰时段的交通。
- 对于以搜索为基础的search-basedRS:有一组出租车和一个乘客，目的是计算针对这一乘客请求的最大SRP的top-k车辆，适用于一个接一个的响应请求的模式，可以满足乘客较高期望的即使响应。

下图展示了一个运行示例，有一组出租车d1-d3
[![image.png](https://s33.postimg.cc/3t8kmz9m7/image.png)](https://postimg.cc/image/70346lu23/)































